
#
# Copyright (c) 2006-2009, Greg M. Kurtzer, Arthur A. Stevens and
# Infiscale, Inc. All rights reserved
#

package Perceus::Config;
use strict;
use warnings;

BEGIN {

   use Exporter;

   our @ISA = ('Exporter');

   our @EXPORT = qw (
        &get_config
        &parse_config
        &write_ethers
   );

   require "/etc/perceus/Perceus_Include.pm";
   push(@INC, "$Perceus_Include::libdir");

}

use Perceus::Debug;
use Perceus::System;
use Perceus::Util;

# Set a global to always return back to if the config has already been parsed.
my %config          = ();

sub
parse_config(@)
{
    &dprint("Entered function");

    my @files            = @_;
    my %ret              = ();
    my $line             = ();
    my @f                = ();
    my $file             = ();

    foreach $file ( @files ) {
        if ( exists($config{"$file"}) ) {
            &dprint("Returning cached configuration hash for '$file'");
            %ret = %{$config{"$file"}};
        } else {
            open(CONFIG, "$file")
                or do {&eprint("Can not open '$file': $!"); exit 1;};
            # we do this silly reversal of the file so that if there are more
            # one configuration entry in the file, the last one takes priority
            # as $config{"entry"}[0] with the next one up at [1], and so on...
            my @file = <CONFIG>;
            foreach $line ( reverse @file ) {
                chomp $line;
                $line =~ s/^\s*#.*$//;
                $line =~ s/\s+$//;
                next if ! $line;
                if ( $line =~ /^\s*(.+?)\s*=\s*"?\s*(.+?)\s*"?\s*$/ ) {
                    @f = split(/\s*,\s*/, $2);
                    push(@{$ret{"$1"}}, @f);
                    &dprint("config key: '$1', value: '$2'\n");
                } else {
                    &dprint("omitting config line: '$line'\n");
                }
            }
            close CONFIG;
            %{$config{"$file"}} = %ret;
        }
    }


    &dprint("Returning function with hash array");
    return %ret;
}

sub
write_ethers()
{
    &dprint("Entered function");

    my $db              = shift;
    my %nodes           = $db->hash_keys();

    open(ETHERS, "> /etc/perceus/ethers");
    print ETHERS "# DO NOT EDIT THIS FILE!\n";
    print ETHERS "# It is generated automatically by Perceus\n";
    foreach ( sort {$nodes{$a} cmp $nodes{$b}} keys %nodes ) {
        if ( $_ =~ /^..:..:..:..:..:..$/ ) {
            print ETHERS "$_ $nodes{$_}\n";
        } else {
            print ETHERS "#$_ $nodes{$_}\n";
        }
    }
    close ETHERS;

    &runcmd("killall -HUP perceus-dnsmasq >/dev/null 2>&1", -1);
    return();
}


sub
get_config
{
    &dprint("Entered function");

    my $Show                = shift;
    my %config              = &parse_config("/etc/perceus/perceus.conf");
    my $output              = ();

    if ( defined($Show) ) {

        if ( $Show eq "statedir" ) {
            $output = "$Perceus_Include::statedir";
        } elsif ( $Show eq "prefix" ) {
            $output = "$Perceus_Include::prefix";
        } elsif ( $Show eq "sysconfdir" ) {
            $output = "$Perceus_Include::sysconfdir";
        } elsif ( $Show eq "libdir" ) {
            $output = "$Perceus_Include::libdir";
        } elsif ( $Show eq "initdir" ) {
            $output = "$Perceus_Include::initdir";
        } elsif ( $Show eq "statedir" ) {
            $output = "$Perceus_Include::statedir";
        } elsif ( $Show eq "vnfs transfer master" ) {
            $output = $config{$Show}[0] || &get_ipaddr($config{"master network device"}[0]);
        } elsif ( exists($config{"$Show"})) {
            $output = "$config{$Show}[0]";
        }
    }

    if ( $output ) {
        &dprint("Returning function with: $output");
    } else {
        &dprint("Returning function");
    }

    return($output);
}

1;
